# Chapter Highlights

Sometimes we get asked questions such as the following:

- What is the most ***important*** aspect of each chapter?
- What do your students ***struggle*** with the most in each chapter?
- What is critical that students ***don't forget*** from each chapter?

Here we provide answers to these questions from our perspective. Keep in mind that these are somewhat arbitrary based on our experiences. You may find the answers to be different based on your experiences.


**Chapter 1 - Language and Data Fundamentals | Objective: Describe computer language translation**

- *Important*: Translation pipeline and Assembly's place in the pipeline, helps answer why Assembly is worth learning
- *Struggle*: Two's Complement
- *Don't forget*: Hexadecimal, it is everywhere

**Chapter 2 - Processor and System Architecture | Objective: Identify computer and processor components**

- *Important*: Register names
- *Struggle*: Keeping the flags straight
- *Don't forget*: Scalar vs. Superscalar processing (Chapter 1 & 2 Supplement)

**Chapter 3 - Assembly and Syntax Fundamentals | Objective: Distinguish between Assembly syntaxes**

- *Important*: Syntax specifics (e.g., parts of a program, different Assemblers)
- *Struggle*: EQU and the current location counter
- *Don't forget*: Data types are primitive, essentially a length of bits

**Chapter 4 - Basic Instructions | Objective: Perform basic arithmetic**

- *Important*: Indirect addressing
- *Struggle*: MUL/DIV setup and variants
- *Don't forget*: To extend the sign when moving values

**Chapter 5 - Intermediate Instructions | Objective: Control program flow**

- *Important*: Primitive nature of data (boolean operators, rollover)
- *Struggle*: Choosing the correct Jump instruction for the data (signed or unsigned) and behavior
- *Don't forget*: Saving and restoring ECX for loop counting

**Chapter 6 - Functions | Objective: Follow function calling conventions**

- *Important*: Function calls follow a convention
- *Struggle*: Remembering implicit operations in instructions such as CALL and RET
- *Don't forget*: Clean up stack

**Chapter 7 - String Instructions and Structures | Objective: Use strings and stuctures**

- *Important*: Clearing or Setting the direction flag for string operations
- *Struggle*: Choosing the correct REP instruction for the desired behavior
- *Don't forget*: Data alignment

**Chapter 8 - Floating-Point Operations | Objective: Execute floating-point operations**

- *Important*: Knowing where to find information
- *Struggle*: Feeling overwhelmed by the amount of detail (e.g., generations, formats, registers, instructions)
- *Don't forget*: To check what a particular system supports

**Chapter 9 - Inline Assembly, Intrinsics, and Macros | Objective: Integreate low-level and high-level code**

- *Important*: Understanding the effects of software and hardware optimizations
- *Struggle*: The syntax details of Clang/GCC inline assembly, memory constraints
- *Don't forget*: Microsoft x64 does not support inline assembly, use Intrinsics

**Chapter 10 - Advanced Processor and System Architecture | Objective: Issue system calls**

- *Important*: Use industry standards, tools, and methods
- *Struggle*: Grasping the interrupt handling process given the possible scenarios and abstractions
- *Don't forget*: To be cautious of hearsay and outdated code examples strewn across the Web

**Chapter 11 - Other Architectures | Objective: Compare computer architectures**

- *Important*: Certain processor designs are well suited for particular devices or applications
- *Struggle*: Carefully reading processor documentation
- *Don't forget*: Basic computing principles are transferable as architectures evolve

**Chapter 12 - Hardware and Electrical Components | Objective: Build simple circuits and devices**

- *Important*: Electrical components use Direct Current
- *Struggle*: Differentiating Current and Voltage
- *Don't forget*: Where component and computer design started and how far we have come, and software requires hardware
